## spring相关
### spring web框架相关
- spring boot特点（约定优于配置）：
    - 有嵌入式servlet(tomcat, jetty和undertow)容器，简化部署
    - 自动装配spring，减少xml文件管理
    - 提供指标，健康检查和外部部署
    - 能独立运行
    - 提供start简化maven配置
- spring中涉及到的设计模式
	- 工厂模式：将bean对象交由工厂对象来创建管理
    - 单例模式：保证一个类仅有一个实例
    - 代理模式(在AOP中体现)：
   	    - jdk动态代理
    	- cglib动态代理
    - 装饰器模式：
   		- 执行持久化操作时，根据客户的需求切换不同的数据源
    - 观察者模式：
   	 	- ApplicationListner接口
    - 策略模式：
   	    - 加载配置文件：classpath:开头，或file:开头
    - 模板模式
   		- JdbcTemplate

### spring IOC
- spring IOC原理：[spring ioc原理总结](https://www.jianshu.com/p/9fe5a3c25ab6)
- spring bean生命周期
    - ![bean生命周期](https://pic2.zhimg.com/880f402c83a0e04f2b4ccfcec3239dc8_r.jpg)
- spring bean作用域
    - **singleton：** spring容器中只会存在一个共享的Bean实例
    - **prototype：** 每次对Bean请求时，都会创建一个新的bean对象
    - **request：** Request作用域针对的是每次的Http请求，Spring容器会根据相关的Bean的定义来创建一个全新的Bean实例。而且该Bean只在当前request内是有效的
    - **session：** 针对http session起作用，Spring容器会根据该Bean的定义来创建一个全新的Bean的实例。而且该Bean只在当前http session内是有效的
    - **global session:**  在global session作用域中所定义的bean被限定于全局的portlet session的生命周期范围之内

### spring AOP
- AOP(面向切面编程)：
    - 静态代理：AspectJ
    - 动态代理：Spring AOP
- spring AOP原理
    - 动态代理
	    - jdk动态代理: java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。
        - cglib动态代理: cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。
        - 使用场景：
            1. 如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP 
            2. 如果目标对象实现了接口，可以强制使用CGLIB实现AOP 
            3. 如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换
        - jdk动态与cglib动态代理的区别:
            - JDK动态代理只能对实现了接口的类生成代理，而不能针对类
            - CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法，若方法声明为final类型，则无法使用cglib重写该方法
- spring AOP实现示例：[基于注解的AOP配置和使用](https://my.oschina.net/sniperLi/blog/491854)
- spring事务控制
    - 实现方式：
        - 使用tx标签方式
        - 使用代理方式
        - 使用拦截器方式
        - 编程式事务(使用transactional注解)
    - 具体使用可参考: [Spring事务管理](https://www.cnblogs.com/newsouls/p/3988216.html)


## java相关
- 算法：
    - hash算法
        - hash碰撞，如何解决hash碰撞
    - 二叉树算法
    - btree算法和b+tree算法
- 集合类框架
    - List：ArrayList和LinkedList
    - Set: HashSet和LInkedHashSet
    - Map: HashMap和LinedHashMap
        - HashMap, HashTable
        - synchronizeMap和ConcurrentHashMap的区别
        - hashtable和hashmap
        - hashmap底层实现
    - 线程安全的list，set，map
- 多线程：
    - 常见概念：
        - 线程安全：当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的
        - 原子性：一个操作是不可中断的，要么全部执行成功要么全部执行失败
        - 有序性：
        - 可见性：线程之间的可见性，一个线程修改的状态对另一个线程是可见的。volatile修饰的变量就具有可见性
        - synchronized: 修饰方法时，锁的就是该方法调用的对象。静态的synchronized方法以Class对象为锁
    - ThreadLocal: 维持线程封闭性，为每个使用该变量的线程都存有一份独立的副本，get总是返回由当前执行线程在调用set时设置的最新值。
    - ReentrantLock：
        - 可定时与可轮询的锁：避免死锁的发生
        - 可中断的锁获取操作，公平队列，以及非块结构的锁
    - 同步容器：HashTable，Vector
    - 并发容器
        - ConcurrentHashMap: 采用并发锁。好处是在并发访问环境下实现更高的吞吐量，而在单线程环境中只损失非常小的性能
        - CopyOnWriteArrayList
        - LinkedBlockingQueue
        - ArrayBlockingQueue
        - CountLownLaunch(闭锁): 在闭锁到达结束状态之前，这扇门一直是关闭的，并且没有任何线程能通过，当到达结束状态时，这扇门会打开并允许所有的线程通过。当闭锁到达结束状态后，将不会再改变状态。
        - Semaphore(信号量)：用来控制同时访问某个特定资源的操作数量，或者同事执行某个指定操作的数量
        - CyclicBarrier(栅栏)：所有线程必须同时到达栅栏位置，才能继续进行。闭锁用于等待时间，而栅栏用于等待其他线程
    - 线程池
        - 队列类型： 无界队列(LinkedBlockingQueue, PriorityBlockingQueue)，有界队列(ArrayBlockingQueue)和同步移交(SynchronousQueue，无界或可以拒绝访问才可以使用)
        - 饱和策略：
            - AbortPolicy: 抛出未检查的RejectedExecutionException
            - CallerRunsPolicy: 既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。
            - DiscardPolicy: 抛弃任务
            - DiscardOldestPolicy：抛弃下一个被执行的任务
        
线程池类型 | 队列类型
---|---
newFixedThreadPool | LinkedBlockingQueue
newSingleTreadPool | LinkedBlockingQueue
newCachedThreadPool | SynchronousQueue

    - 乐观锁：每次操作数据的时候，都认为别的线程不会参与竞争修改，也不加锁
    - 悲观锁：独占锁
    - 线程间相互通信
    - Thread
        - sleep
        - wait, notify
        - 

- jvm内存分布：方法区，堆，程序计数器，本地放发展，虚拟机栈
- 如何判断对象是否已经“消亡“
    1. 引用计数法:一个对象如果没有任何引用指向它，就可认为该对象已经”消亡“，这种方法有个缺点就是无法检测到引用环的存在。
    2. 根搜索算法（GCRootsTracing）:通过一系列叫做”GCRoots“的对象作为起点向下搜索，走过的路径称为引用链,当一个对象到GCRoots没有任何引用链时，表明该对象已经”消亡“。
        - 可作为GcRoots四种对象的情况
            - 虚拟机栈中引用的对象（栈帧中的本地变量表）；
            - 方法区中类静态属性引用的对象；
            - 方法区中常量引用的对象；
            - 本地方法栈中JNI（Native方法）引用的对象。
- 垃圾收集算法
    - 复制-清除算法
    - 标记-清除算法
    - 标记-整理算法
    - 分代回收算法
- Minor GC触发条件：当Eden区满时，或者新创建的对象大小 > Eden所剩空间
- Full GC触发条件
    - 调用System.gc时，系统建议执行Full GC，但是不必然执行
    - 老年代空间不足
    - 方法区空间不足
    - 通过Minor GC后进入老年代的平均大小大于老年代的可用内存
- [Minor gc 和 full gc何时触发](https://blog.csdn.net/summerZBH123/article/details/81131945)
- [垃圾收集器](https://www.cnblogs.com/chengxuyuanzhilu/p/7088316.html)
- [jvm类加载机制](http://www.importnew.com/25295.html)
- [jvm面试相关](https://www.cnblogs.com/aspirant/p/8662690.html)
- 网络通信
    - BIO： Blocking IO，阻塞式IO。同步阻塞。
    - NIO：Non-blocking IO，非阻塞式IO。同步非阻塞。
    - AIO：Async IO，异步IO。异步非阻塞。
    - [reactor线程模型](https://www.cnblogs.com/duanxz/p/3696849.html)
- 数据库连接池
    - dbcp
    - c3p0
    - druid
    - hikaricp

## 其他
- 日志
    - log4j
    - logback

## 网络
- OSGI七层网络协议
    - 应用层：HTTP,FTP,NFS
    - 表示层：Telnet, SNMP
    - 会话层: SMTP
    - 传输层：TCP, UDP
    - 网络层：IP, ICMP
    - 数据链路层：Ethernet, FDDI
    - 物理层: IEEE 802.1A, IEEE 802.2
- TCP/IP四层网络协议
    - 应用层：Telenet, FTP, SMTP, HTTP
    - 传输层: TCP, UDP
    - 网络层: IP
    - 链路层: 设备驱动程序及接口卡
- tcp
    - 三次握手
        - 主动连接端发送一个SYN包给被动连接端
        - 被动连接端收到SYN包后，发送一个带ACK和SYN标志的包给主动连接端
        - 主动连接端发送一个带ACK标志的包给被动连接端，握手动作完成
    - 四次挥手
        - 主动关闭端发送一个FIN包给被动关闭端；
        - 被动关闭端收到FIN包后，发送一个ACK包给主动关闭端；
        - 被动关闭端发送了ACK包后，再发送一个FIN包给主动关闭端；
        - 主动关闭端收到FIN包后，发送一个ACK包，当被动关闭端收到ACK包后，四次挥手动作完成，连接断开。
    - netstat中的各种状态：
        - CLOSED：初始（无连接）状态。
        - LISTEN：侦听状态，等待远程机器的连接请求。
        - SYN_SEND：在TCP三次握手期间，主动连接端发送了SYN包后，进入SYN_SEND状态，等待对方的ACK包。
        - SYN_RECV：在TCP三次握手期间，主动连接端收到SYN包后，进入SYN_RECV状态。
        - ESTABLISHED：完成TCP三次握手后，主动连接端进入ESTABLISHED状态。此时，TCP连接已经建立，可以进行通信。
        - FIN_WAIT_1：在TCP四次挥手时，主动关闭端发送FIN包后，进入FIN_WAIT_1状态。
        - FIN_WAIT_2：在TCP四次挥手时，主动关闭端收到ACK包后，进入FIN_WAIT_2状态。
        - TIME_WAIT：在TCP四次挥手时，主动关闭端发送了ACK包之后，进入TIME_WAIT状态，等待最多MSL时间，让被动关闭端收到ACK包。
        - CLOSING：在TCP四次挥手期间，主动关闭端发送了FIN包后，没有收到对应的ACK包，却收到对方的FIN包，此时，进入CLOSING状态。
        - CLOSE_WAIT：在TCP四次挥手期间，被动关闭端收到FIN包后，进入CLOSE_WAIT状态。
        - LAST_ACK：在TCP四次挥手时，被动关闭端发送FIN包后，进入LAST_ACK状态，等待对方的ACK包。
    - 主动连接端可能的状态有：CLOSED, SYN_SEND, ESTABLISHED。
    - 主动关闭端可能的状态有：FIN_WAIT_1, FIN_WAIT_2, TIME_WAIT。
    - 被动连接端可能的状态有：LISTEN, SYN_RECV, ESTABLISHED。
    - 被动关闭端可能的状态有：CLOSE_WAIT, LAST_ACK, CLOSED。
- udp：面向非连接的协议，可靠性不高
- ipv4和ipv6的区别
    - ipv4的ip地址长度为32，即2^32-1个地址；ipv6的ip地址长度为128，即2^128-1个地址
- https
    - ![https单向加密](https://img-blog.csdn.net/20160310160503593)
    - ![https双向加密](https://img-blog.csdn.net/20160310160519781)

## spring cloud微服务框架
### spring cloud eureka
- 服务注册中心

### spring cloud ribbon
- 客户端负载均衡

### spring cloud hystrix
- 服务容错保护

### spring cloud feign
- 声明式服务调用

### spring cloud zuul
- API网关服务

### spring cloud config
- 分布式配置中心

### spring cloud bus
- 消息总线

### spring cloud stream
- 消息驱动的微服务

### spring cloud sleuth
- 分布式服务跟踪

### zipkin

### elk

## 数据库相关
### MySql数据库
- mysql隔离级别：读未提交（read-uncommitted），不可重复读（read-committed），可重复读（repeatable-read），串行化（serializable）
- mysql部署模式
    - 主备模式：通过二进制日志（binLog日志），传到服务的服务器上，然后在从服务器上对这些日志从新执行，从而实现从服务器与主服务器的数据同步
        - 优点：
            - 如果主服务器出现问题，可以快速切换到从服务器提供服务。
            - 可以在从服务器上执行查询，降低主服务器的压力
            - 可以在从服务器上执行备份，以避免备份期间影响主服务器的性能
        - 缺点：
            - 由于MySQL实现的是异步复制，所以主从服务器之间的数据存在一定差异，对实时性要求高的数据仍然需要从主服务器上获得。
- mysql索引
    - **b+tree索引:** B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接。
    - **hash索引:** 哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快
    - hash索引与B+树索引的区别：
        - 如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；
        - 如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；
        - 哈希索引也没办法利用索引完成排序，以及like ‘xxx%’这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；
        - 哈希索引也不支持多列联合索引的最左匹配规则；
        - B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。 
    - 建立索引的原则
        - 选择唯一性索引
        - 限制索引的数目
        - 尽量使用数据量少的索引
        - 索引列不能参与计算，保持列“干净”
        - 为经常需要排序、分组和联合操作的字段建立索引
        - 为常作为查询条件的字段建立索引
        - 最左匹配原则
    - 有索引但未被使用的情况
        - Like的参数以通配符开头时：尽量避免Like的参数以通配符开头，否则数据库引擎会放弃使用索引而进行全表扫描
        - where条件不符合最左前缀原则
        - 尽量避免使用!= 或 <>操作符，否则数据库引擎会放弃使用索引而进行全表扫描
        - 索引列参与计算
        - 对字段进行null值判断
        - 使用or来连接条件
        
   
## 其他系统
### redis缓存
- redis的优点：
    - 支持多种数据结构类型
    - 提供主从复制
    - 数据持久化
- 缺点
    - 不具备自动容错和恢复功能
    - 主从复制采用全量复制
    - 主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性
- redis为何速度快
    - 完全基于内存
    - 单线程操作，避免了频繁的上下文切换
    - 多路复用IO：多路指多个网络连接，复用指使用同一个线程
- redis部署模式
    - 主备模式
    - 哨兵模式
    - 集群模式
- redis持久化方式
    - redis的持久化是可以禁用的，并且两种持久化是可以同时存在的
    - **快照(RDB文件)：** 在一个特定的间隔保存那个时间点的一个数据快照
        - 工作原理：
            1. Redis调用fork()，产生一个子进程。
            2. 子进程把数据写到一个临时的RDB文件。
            3. 当子进程写完新的RDB文件后，把旧的RDB文件替换掉。
    - **追加式(AOF文件)：** 记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟Redis协议一致，以追加的方式进行保存。
- redis中数据结构: String, Hash, List, Set, Sorted Set
- redis实现全局分布式锁
- 缓存常见问题
    - 缓存穿透
    - 缓存失效
    - 缓存雪崩

### nginx
- 一个高性能的HTTP和反向代理服务
- 负载均衡策略：
    - 轮询模式：每个请求会按时间顺序逐一分配到不同的后端服务器
    - 权重方式：在轮询策略的基础上指定轮询的几率，权重越高分配到需要处理的请求越多
    - 依据ip分配方式：指定负载均衡器按照基于客户端IP的分配方式，这个方法确保了相同的客户端的请求一直发送到相同的服务器，以保证session会话
    - 最少连接方式：把请求转发给连接数较少的后端服务器，此负载均衡策略适合请求处理时间长短不一造成服务器过载的情况
    - 响应时间方式：按照服务器端的响应时间来分配请求，响应时间短的优先分配
    - 依据URL分配方式：按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，要配合缓存命中来使用

## 大数据相关
- ![大数据架构图](http://img.mp.itc.cn/upload/20160512/aa11dbf4af93433fb0c1910c0a233729_th.jpg)
- hadoop: hdfs+MapReduce

### 批处理和流处理
- hbase：非结构化数据存储的数据库。另一个不同的是HBase基于列的而不是基于行的模式。表在HBase中是物理表，而不是逻辑表，提供一个超大的内存hash表，搜索引擎使用它来存储索引，以满足查询的实时性需求。
- storm：分布式、高容错的实时计算系统
- spark：同时支持流处理和批处理的计算引擎。Spark的技术理念是基于批来模拟流的计算
- flink：同时支持流处理和批处理的计算引擎。Flink则完全相反，它采用的是基于流计算来模拟批计算。高吞吐、低延迟


### 搜索引擎
- impala：Impala是基于Hive的大数据实时分析查询引擎，直接使用Hive的元数据库Metadata,意味着impala元数据都存储在Hive的metastore中
- kylin：数据提取建模，通过HIVE将数据转换成cube，存入HBASE中方便查询。这个就是要求提前建立cube，智能应对特定的模型
- hive：将结构化的数据文件映射为一张数据库表，并提供简单的sql查询功能，可以将sql语句转换为MapReduce任务进行运行

### 外部工具
- kafka：开源流处理平台
- flume：高可用的，高可靠的，分布式的海量日志采集、聚合和传输的系统

## 容器相关
- docker
- K8S
- zipkin
- elk